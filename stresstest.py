# -*- coding: utf-8 -*-
"""StressTest.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cADp17vC8rWDGYnaJCoMsarZEva47QyJ
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import math
from scipy.stats import norm
import yfinance as yf
from datetime import datetime, timedelta


# load it up
data = pd.read_csv('/content/drive/My Drive/series_test1.csv')
data_clean = data.drop('Date', axis=1)
data_clean

index_symbol = "^GSPC"
# Calculate the date range for the last 30 trading days
end_date = datetime.now()
start_date = end_date - timedelta(days=365)
real_crisis1 = yf.download(index_symbol, '2000-03-24', '2007-05-30')
real_crisis2 = yf.download(index_symbol, '2007-10-09', '2013-03-28')
C1_df = pd.DataFrame(real_crisis1)
C2_df = pd.DataFrame(real_crisis2)
# Fetch historical data from Yahoo Finance for the S&P 500 index
data = yf.download(index_symbol, start=start_date, end=end_date)
closing_prices = data['Close']
df_closing_prices = pd.DataFrame(closing_prices)
df_closing_prices.rename(columns={'Close':0}, inplace=True)
C1 = C1_df['Close']
C2 = C2_df['Close']
c1c = pd.DataFrame(C1)
c2c = pd.DataFrame(C2)
c1c_df = c1c.reset_index(drop=True)
c2c_df = c2c.reset_index(drop=True)

num_duplicates = 197
df_duplicates = pd.concat([df_closing_prices[0]] * num_duplicates, axis=1)

# Rename the columns to distinguish them
column_names = [f'{i+1}' for i in range(-1,num_duplicates-1)]
df_duplicates.columns = column_names

# Concatenate the duplicates DataFrame with the original DataFrame to create dataframe for volatility calculation
result_df = df_duplicates
result_df.reset_index(inplace=True)
result_df_clean = result_df.drop('Date', axis=1)
return_result_df = result_df_clean.pct_change()
return_result_df = return_result_df.fillna(0)
#volatility
vola = np.std(return_result_df['0']) * np.sqrt(252)

vola

def calculate_option_prices(stock_data, risk_free_rate, time_to_maturity, volatility, option_type):
    option_prices = []

    for column in stock_data.columns:
        stock_prices = stock_data[column]
        strike_price = stock_prices.iloc[0] * 1.05  # Set strike price as 105% of the first row value

        option_prices_column = []
        current_time_to_maturity = time_to_maturity  # Store the initial time to maturity for each column

        for i, stock_price in enumerate(stock_prices):
            if current_time_to_maturity <= 0:
                # Reached time_to_maturity limit, append previous option price
                option_prices_column.append(option_prices_column[-1])
                continue

            d1 = (math.log(stock_price / strike_price) + (risk_free_rate + 0.5 * volatility**2) * current_time_to_maturity) / (volatility * math.sqrt(current_time_to_maturity))
            d2 = d1 - volatility * math.sqrt(current_time_to_maturity)

            if option_type.lower() == 'call':
                option_price = stock_price * norm.cdf(d1) - strike_price * math.exp(-risk_free_rate * current_time_to_maturity) * norm.cdf(d2)
            elif option_type.lower() == 'put':
                option_price = strike_price * math.exp(-risk_free_rate * current_time_to_maturity) * norm.cdf(-d2) - stock_price * norm.cdf(-d1)
            else:
                raise ValueError("Invalid option type. Must be either 'call' or 'put'.")

            option_prices_column.append(option_price)

            # Decrement current_time_to_maturity for the next iteration
            current_time_to_maturity -= 1 / 252  # Assuming 252 trading days in a year

        option_prices.append(option_prices_column)

    option_data = pd.DataFrame(option_prices).T
    option_data.columns = stock_data.columns

    return option_data




stock_data = data_clean

risk_free_rate = 0.0525  # American FED interest
time_to_maturity = [0.5, 1, 1.5, 2]
volatility = vola
option_type = 'call'

option_data = calculate_option_prices(stock_data, risk_free_rate, time_to_maturity[0], volatility, option_type)
option_data1 = calculate_option_prices(stock_data, risk_free_rate, time_to_maturity[1], volatility, option_type)
option_data2 = calculate_option_prices(stock_data, risk_free_rate, time_to_maturity[2], volatility, option_type)
option_data3 = calculate_option_prices(stock_data, risk_free_rate, time_to_maturity[3], volatility, option_type)
print(option_data)

portfolio_options = data_clean.add(option_data).add(option_data1).add(option_data2).add(option_data3)

def calculate_portfolio_values(df: pd.DataFrame, initial_investment: float) -> pd.DataFrame:
    # Make a copy of the DataFrame to avoid modifying the original data
    df_copy = df.copy()

    # Iterate over the columns of the DataFrame, skipping the 'Date' column
    for column in df.columns[0:]:
        # Calculate daily returns for the current column
        df_copy[column] = df_copy[column].pct_change().fillna(0)

        # Calculate daily portfolio values based on the returns
        portfolio_values = [initial_investment]
        for i in range(1, len(df_copy[column])):
            portfolio_value = portfolio_values[i-1] * (1 + df_copy[column].iloc[i])
            portfolio_values.append(portfolio_value)

        # Replace the column data with the calculated portfolio values
        df_copy[column] = portfolio_values

    return df_copy

data_val = calculate_portfolio_values(data_clean, 10000)
portfolio_options_val = calculate_portfolio_values(portfolio_options, 10000)
portfolio_options_val
c1c_df_val = calculate_portfolio_values(c1c_df,10000)
c2c_df_val = calculate_portfolio_values(c2c_df,10000)

class StockMetrics:
    def __init__(self, data):
        self.data = data
        self.results = pd.DataFrame(index=data.columns)

    def calculate_portfolio_return(self):
        portfolio_return = self.data.pct_change()
        return portfolio_return

    def calculate_overall_portfolio_return(self):
        first_row = self.data.iloc[0]
        last_row = self.data.iloc[-1]
        overall_return = (last_row / first_row) - 1
        return overall_return

    def calculate_var(self, column, confidence_level=0.99):
        portfolio_return = self.calculate_portfolio_return()[column]
        non_nan_returns = portfolio_return[~np.isnan(portfolio_return)]

        if len(non_nan_returns) > 0:
            var = np.percentile(non_nan_returns, (1 - confidence_level) * 100)
        else:
            var = 0

        return var

    def calculate_expected_shortfall(self, column, confidence_level=0.99):
        portfolio_return = self.calculate_portfolio_return()[column]
        non_nan_returns = portfolio_return[~np.isnan(portfolio_return)]

        if len(non_nan_returns) > 0:
            var = self.calculate_var(column, confidence_level)
            mask = portfolio_return <= var
            es = portfolio_return[mask].mean()
        else:
            es = 0

        return es

    def calculate_volatility(self, column):
        portfolio_return = self.calculate_portfolio_return()[column]
        volatility = portfolio_return.std()
        return volatility

    def calculate_maximum_drawdown(self, column):
        portfolio_return = self.calculate_portfolio_return()[column]
        cumulative_return = (1 + portfolio_return).cumprod()
        rolling_max = cumulative_return.cummax()
        drawdown = (cumulative_return - rolling_max) / rolling_max
        max_drawdown = drawdown.min()
        return max_drawdown

    def calculate_metrics(self):
        for column in self.data.columns:
            self.results.loc[column, 'Portfolio Return'] = self.calculate_overall_portfolio_return()[column].sum()
            self.results.loc[column, 'VaR 99%'] = self.calculate_var(column)
            self.results.loc[column, 'Expected Shortfall'] = self.calculate_expected_shortfall(column)
            self.results.loc[column, 'Volatility'] = self.calculate_volatility(column)
            self.results.loc[column, 'Maximum Drawdown'] = self.calculate_maximum_drawdown(column)

    def plot_histogram(self, metric):
        plt.figure(figsize=(16, 8))
        plt.hist(self.results[metric].values, bins=50, alpha=0.5, edgecolor='black')
        plt.xlabel(metric)
        plt.ylabel('Frequency')
        plt.title(f'{metric} Histogram')
        plt.show()


def calculate_metric_means(results_df):
    # Calculate the mean of each metric
    mean_portfolio_return = results_df['Portfolio Return'].mean()
    mean_var = results_df['VaR 99%'].mean()
    mean_expected_shortfall = results_df['Expected Shortfall'].mean()
    mean_volatility = results_df['Volatility'].mean()
    mean_max_drawdown = results_df['Maximum Drawdown'].mean()

    # Create a new DataFrame to store the means
    metric_means_df = pd.DataFrame({
        'Mean Portfolio Return': [mean_portfolio_return],
        'Mean VaR 99%': [mean_var],
        'Mean Expected Shortfall': [mean_expected_shortfall],
        'Mean Volatility': [mean_volatility],
        'Mean Maximum Drawdown': [mean_max_drawdown]
    })

    return metric_means_df
# Example usage
data = portfolio_options_val

metrics = StockMetrics(data)
metrics.calculate_metrics()
results_df = metrics.results

metrics.plot_histogram('Portfolio Return')
metrics.plot_histogram('VaR 99%')
metrics.plot_histogram('Expected Shortfall')
metrics.plot_histogram('Volatility')
metrics.plot_histogram('Maximum Drawdown')

results_df



metrics = StockMetrics(data_val)
metrics.calculate_metrics()
results_df = metrics.results

metrics.plot_histogram('Portfolio Return')
metrics.plot_histogram('VaR 99%')
metrics.plot_histogram('Expected Shortfall')
metrics.plot_histogram('Volatility')
metrics.plot_histogram('Maximum Drawdown')
calculate_metric_means(results_df)

data = c1c_df_val

metrics = StockMetrics(data)
metrics.calculate_metrics()
results_df = metrics.results

metrics.plot_histogram('Portfolio Return')
metrics.plot_histogram('VaR 99%')
metrics.plot_histogram('Expected Shortfall')
metrics.plot_histogram('Volatility')
metrics.plot_histogram('Maximum Drawdown')
calculate_metric_means(results_df)

data = c2c_df_val

metrics = StockMetrics(data)
metrics.calculate_metrics()
results_df = metrics.results

metrics.plot_histogram('Portfolio Return')
metrics.plot_histogram('VaR 99%')
metrics.plot_histogram('Expected Shortfall')
metrics.plot_histogram('Volatility')
metrics.plot_histogram('Maximum Drawdown')
calculate_metric_means(results_df)

GFC = {'Portfolio Return': -0.00147,
       'VaR 99%': -0.048159,
       'Expected Shortfall': -0.065284,
       'Volatility': 0.01613,
       'Maximum Drawdown': -0.567012}

DotCom = {'Portfolio Return': -0.006121,
          'VaR 99%': -0.028024,
          'Expected Shortfall': -0.03559,
          'Volatility': 0.010922,
          'Maximum Drawdown': -0.490268}

class StockMetrics:
    def __init__(self, data):
        self.data = data
        self.results = pd.DataFrame(index=data.columns)

    def calculate_portfolio_return(self):
        portfolio_return = self.data.pct_change()
        return portfolio_return

    def calculate_overall_portfolio_return(self):
        first_row = self.data.iloc[0]
        last_row = self.data.iloc[-1]
        overall_return = (last_row / first_row) - 1
        return overall_return

    def calculate_var(self, column, confidence_level=0.99):
        portfolio_return = self.calculate_portfolio_return()[column]
        non_nan_returns = portfolio_return[~np.isnan(portfolio_return)]

        if len(non_nan_returns) > 0:
            var = np.percentile(non_nan_returns, (1 - confidence_level) * 100)
        else:
            var = 0

        return var

    def calculate_expected_shortfall(self, column, confidence_level=0.99):
        portfolio_return = self.calculate_portfolio_return()[column]
        non_nan_returns = portfolio_return[~np.isnan(portfolio_return)]

        if len(non_nan_returns) > 0:
            var = self.calculate_var(column, confidence_level)
            mask = portfolio_return <= var
            es = portfolio_return[mask].mean()
        else:
            es = 0

        return es

    def calculate_volatility(self, column):
        portfolio_return = self.calculate_portfolio_return()[column]
        volatility = portfolio_return.std()
        return volatility

    def calculate_maximum_drawdown(self, column):
        portfolio_return = self.calculate_portfolio_return()[column]
        cumulative_return = (1 + portfolio_return).cumprod()
        rolling_max = cumulative_return.cummax()
        drawdown = (cumulative_return - rolling_max) / rolling_max
        max_drawdown = drawdown.min()
        return max_drawdown

    def calculate_metrics(self):
        for column in self.data.columns:
            self.results.loc[column, 'Portfolio Return'] = self.calculate_overall_portfolio_return()[column]
            self.results.loc[column, 'VaR 99%'] = self.calculate_var(column)
            self.results.loc[column, 'Expected Shortfall'] = self.calculate_expected_shortfall(column)
            self.results.loc[column, 'Volatility'] = self.calculate_volatility(column)
            self.results.loc[column, 'Maximum Drawdown'] = self.calculate_maximum_drawdown(column)

    def plot_histogram(self, metric):
        plt.figure(figsize=(16, 8))
        plt.hist(self.results[metric].values, bins=50, alpha=0.5, edgecolor='black')
        plt.xlabel(metric)
        plt.ylabel('Frequency')
        plt.title(f'{metric} Histogram')

        # Plot the vertical lines for the value from GFC dictionary and DotCom dictionary, if available
        if metric in GFC:
            gfc_value = GFC[metric]
            plt.axvline(x=gfc_value, color='red', linestyle='dashed', linewidth=2, label=f'GFC Value ({gfc_value:.5f})')

        if metric in DotCom:
            dotcom_value = DotCom[metric]
            plt.axvline(x=dotcom_value, color='blue', linestyle='dashed', linewidth=2, label=f'DotCom Value ({dotcom_value:.5f})')

        # Calculate the mean value of the data_val (input data) for the current metric
        if metric in self.results.columns:
            mean_value = self.results[metric].mean()
            plt.axvline(x=mean_value, color='green', linestyle='dashed', linewidth=2, label=f'Mean Value ({mean_value:.5f})')

        plt.legend()
        plt.show()


# Example usage
data = data_val

metrics = StockMetrics(data)
metrics.calculate_metrics()
results_df = metrics.results

metrics.plot_histogram('Portfolio Return')
metrics.plot_histogram('VaR 99%')
metrics.plot_histogram('Expected Shortfall')
metrics.plot_histogram('Volatility')
metrics.plot_histogram('Maximum Drawdown')
results_df

import pandas as pd

import numpy as np



# Define a function to implement the task

def traffic_light_system(input_df, thresholds_df):

    # Initialize counter dataframe

    counter_df = pd.DataFrame(index=['Green', 'Yellow', 'Red'], columns=input_df.columns).fillna(0)



    # Iterate over each column

    for col in input_df.columns:

        # Get the thresholds for the column

        yellow_threshold = thresholds_df.loc['Yellow', col]

        red_threshold = thresholds_df.loc['Red', col]



        # Iterate over each value in the column

        for value in input_df[col]:

            # Increment the appropriate counter based on the value and thresholds

            if value > yellow_threshold:

                counter_df.loc['Green', col] += 1

            elif value > red_threshold:

                counter_df.loc['Yellow', col] += 1

            else:

                counter_df.loc['Red', col] += 1



    return counter_df



# Generate synthetic data for testing

np.random.seed(0)



# Input dataframe

input_df = results_df



# Correct the Thresholds dataframe

thresholds_df = pd.DataFrame({

    'Portfolio Return': {'Yellow': -0.006121, 'Red': -0.0079573},

    'VaR 99%': {'Yellow': -0.048159, 'Red': -0.0626067},

    'Expected Shortfall': {'Yellow': -0.065284, 'Red': -0.0848692},

    'Maximum Drawdown': {'Yellow': -0.567012, 'Red': -0.7371156},

    'Volatility': {'Yellow': 0.01613, 'Red': 0.020969}

})



# Test the function again

counter_df = traffic_light_system(input_df, thresholds_df)

counter_df

counter_df_percentage = counter_df / len(input_df) * 100
counter_df_percentage

# Set up the matplotlib figure
import seaborn as sns
f, axes = plt.subplots(2, 1, figsize=(10, 10), sharex=True)



# Generate a stacked bar plot
counter_df.plot(kind='bar', stacked=True, ax=axes[0])
axes[0].set_title('Stacked Bar Plot of Counts')
axes[0].set_ylabel('Count')



# Generate a heatmap
sns.heatmap(counter_df_percentage, annot=True, fmt=".2f", linewidths=.5, ax=axes[1], cmap='YlGnBu')
axes[1].set_title('Heatmap of Percentages')



plt.tight_layout()
plt.show()

data = portfolio_options_val

metrics = StockMetrics(data)
metrics.calculate_metrics()
results_df = metrics.results

metrics.plot_histogram('Portfolio Return')
metrics.plot_histogram('VaR 99%')
metrics.plot_histogram('Expected Shortfall')
metrics.plot_histogram('Volatility')
metrics.plot_histogram('Maximum Drawdown')

def plot_all_time_series(data_frame, title='title'):
    plt.figure(figsize=(10, 6))

    for column_name in data_frame.columns:
        plt.plot(data_frame.index, data_frame[column_name], marker='None', linestyle='-', label=column_name)

    plt.xlabel('Days')
    plt.ylabel('Asset value')
    plt.title(title)

    plt.grid(True)
    plt.show()



# Call the function to plot all time series
plot_all_time_series(portfolio_options_val, title='Time Series of All Scenarios with Options')
plot_all_time_series(data_val, title='Time Series of All Scenarios')
plot_all_time_series(c1c_df_val, title='Crisis 1')
plot_all_time_series(c2c_df_val, title='Crisis 2')

def calculate_std_for_row_ranges(data_frame, row_ranges):
    std_results = {}

    for i, range_end in enumerate(row_ranges):
        selected_rows = data_frame.iloc[:range_end]
        std_results[f"Vola until_{range_end}"] = selected_rows.std()/selected_rows.mean()

    std_results["total"] = data_frame.std()/data_frame.mean()

    return std_results


# List of row indices for which to calculate standard deviation
row_ranges = [126, 252, 378, 504]

# Call the function to calculate standard deviation for each row range
vola_pf_options = calculate_std_for_row_ranges(portfolio_options_val, row_ranges)
vola_pf = calculate_std_for_row_ranges(data_val, row_ranges)
vola_c1 = calculate_std_for_row_ranges(c1c_df_val, row_ranges)
vola_c2 = calculate_std_for_row_ranges(c2c_df_val, row_ranges)
df_vola_options = pd.DataFrame(vola_pf_options)
df_vola = pd.DataFrame(vola_pf)
df_vola_c1 = pd.DataFrame(vola_c1)
df_vola_c2 = pd.DataFrame(vola_c2)
vola_OV_ = {'Portfolio':['SP500 with Opt.', 'SP500', 'Crisis 1', 'Crisis2'],
            '126 days mean':[np.mean(df_vola_options['Vola until_126']),np.mean(df_vola['Vola until_126']),np.mean(df_vola_c1['Vola until_126']),np.mean(df_vola_c2['Vola until_126'])],
            '252 days mean':[np.mean(df_vola_options['Vola until_252']),np.mean(df_vola['Vola until_252']),np.mean(df_vola_c1['Vola until_252']),np.mean(df_vola_c2['Vola until_252'])],
            '378 days mean':[np.mean(df_vola_options['Vola until_378']),np.mean(df_vola['Vola until_378']),np.mean(df_vola_c1['Vola until_378']),np.mean(df_vola_c2['Vola until_378'])],
            '504 days mean':[np.mean(df_vola_options['Vola until_504']),np.mean(df_vola['Vola until_504']),np.mean(df_vola_c1['Vola until_504']),np.mean(df_vola_c2['Vola until_504'])],
            'total':[np.mean(df_vola_options['total']),np.mean(df_vola['total']),np.mean(df_vola_c1['total']),np.mean(df_vola_c2['total'])]}
vola_OV_df = pd.DataFrame(vola_OV_)
vola_OV_df.set_index('Portfolio', inplace=True)
print(vola_OV_df)

def plot_two_distributions(df1, df2, df3, df4, column1, column2, column3, column4, title='title', label1='Distribution 1', label2='Distribution 2', label3='Distribution 3', label4='Distribution 4',bins=10):
    """
    Plot two distributions from two different DataFrames on the same plot.

    Parameters:
        df1 (pd.DataFrame): The first DataFrame.
        df2 (pd.DataFrame): The second DataFrame.
        column1 (str): Name of the column from df1 to plot.
        column2 (str): Name of the column from df2 to plot.
        label1 (str): Label for the first distribution (default: 'Distribution 1').
        label2 (str): Label for the second distribution (default: 'Distribution 2').
        bins (int): Number of bins to use in the histograms (default: 10).
    """
    plt.figure(figsize=(10, 6))

    plt.hist(df1[column1], bins=bins, alpha=0.5, edgecolor='black', label=label1)
    plt.hist(df2[column2], bins=bins, alpha=0.5, edgecolor='black', label=label2)
    plt.hist(df3[column3], bins=bins, alpha=0.5, edgecolor='black', label=label3)
    plt.hist(df4[column4], bins=bins, alpha=0.5, edgecolor='black', label=label4)

    plt.xlabel('Values')
    plt.ylabel('Frequency')
    plt.title(title)
    plt.legend()

    plt.show()

plot_two_distributions(df_vola_options, df_vola, df_vola_c1, df_vola_c2, column1='Vola until_126', column2='Vola until_126', column3='Vola until_126', column4='Vola until_126', title='Volatility distribution - 126 days', label1='Volatility with options', label2='Volatility with no options', label3='Crisis 1', label4='Crisis 2', bins=15)
plot_two_distributions(df_vola_options, df_vola, df_vola_c1, df_vola_c2, column1='Vola until_252', column2='Vola until_252', column3='Vola until_252', column4='Vola until_252', title='Volatility distribution - 256 days', label1='Volatility with options', label2='Volatility with no options', label3='Crisis 1', label4='Crisis 2', bins=15)
plot_two_distributions(df_vola_options, df_vola, df_vola_c1, df_vola_c2, column1='Vola until_378', column2='Vola until_378',  column3='Vola until_378', column4='Vola until_378', title='Volatility distribution - 382 days',label1='Volatility with options', label2='Volatility with no options', label3='Crisis 1', label4='Crisis 2', bins=15)
plot_two_distributions(df_vola_options, df_vola, df_vola_c1, df_vola_c2, column1='Vola until_504', column2='Vola until_504',  column3='Vola until_504', column4='Vola until_504', title='Volatility distribution - 512 days', label1='Volatility with options', label2='Volatility with no options', label3='Crisis 1', label4='Crisis 2', bins=15)
plot_two_distributions(df_vola_options, df_vola, df_vola_c1, df_vola_c2, column1='total', column2='total',  column3='total', column4='total', title='Volatility distribution - in total', label1='Volatility with options', label2='Volatility with no options', label3='Crisis 1', label4='Crisis 2', bins=15)

def plot_normalized_time_series(df1, df2, df3, color1='blue', color2='green', color3='red'):
    # Normalize the x-axis using the number of rows
    def normalize_time_series(df):
        df['Normalized_Row'] = np.arange(len(df)) / (len(df) - 1)
        return df

    df1 = normalize_time_series(df1)
    df2 = normalize_time_series(df2)
    df3 = normalize_time_series(df3)

    # Create a figure and axis
    fig, ax = plt.subplots()

    for _, column in df3.iloc[:, 1:].iteritems():
        # Normalize the time series
        column = normalize_time_series(column.to_frame())
        ax.plot(column['Normalized_Row'], column.iloc[:, 0], color=color3, alpha=1.0)
    # Plot the dataframes on the same plot using the normalized x-axis
    ax.plot(df1['Normalized_Row'], df1.iloc[:, 0], color=color1, label='DotCom Bubble', alpha=1.0)
    ax.plot(df2['Normalized_Row'], df2.iloc[:, 0], color=color2, label='GFC', alpha=1.0)


    # Set x-axis and y-axis labels
    ax.set_xlabel('Normalized Trading Days')
    ax.set_ylabel('Asset Value')

    # Set the legend
    ax.legend()

    # Show the plot
    plt.show()

# Example usage:
# Assuming you have three dataframes df1, df2, and df3 containing the time series data
# with columns 'Value', you can call the function like this:
# plot_normalized_time_series(df1, df2, df3)
#Series Max Drawdown:  73  57  142  23 169  193  61  156  84  66 <--- the worst 10
maxDD_val = pd.DataFrame(data_val.iloc[:, 73])
maxDD_val.insert(loc=1, column = 1, value = data_val.iloc[:, 57])
maxDD_val.insert(loc=1, column = 2, value = data_val.iloc[:, 142])
maxDD_val.insert(loc=1, column = 3, value = data_val.iloc[:, 23])
maxDD_val.insert(loc=1, column = 4, value = data_val.iloc[:, 169])
maxDD_val.insert(loc=1, column = 5, value = data_val.iloc[:, 193])
maxDD_val.insert(loc=1, column = 6, value = data_val.iloc[:, 61])
maxDD_val.insert(loc=1, column = 7, value = data_val.iloc[:, 156])
maxDD_val.insert(loc=1, column = 8, value = data_val.iloc[:, 84])
maxDD_val.insert(loc=1, column = 9, value = data_val.iloc[:, 66])
maxDD_val
plot_normalized_time_series(c1c_df_val, c2c_df_val, maxDD_val, color1='blue', color2='green', color3='red')